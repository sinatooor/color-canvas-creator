import { ArtStyle, ComplexityLevel } from "../types";

const EDGE_FUNCTION_URL = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/generate-illustration`;

// Helper to resize image to prevent payload issues (Max 1024px)
async function resizeImage(base64Str: string, maxDim: number = 1024): Promise<string> {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = base64Str;
    img.onload = () => {
      let w = img.width;
      let h = img.height;
      
      if (w > maxDim || h > maxDim) {
        if (w > h) {
          h = Math.round((h * maxDim) / w);
          w = maxDim;
        } else {
          w = Math.round((w * maxDim) / h);
          h = maxDim;
        }
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.drawImage(img, 0, 0, w, h);
        // Use JPEG with 0.85 quality to reduce base64 string size significantly
        resolve(canvas.toDataURL('image/jpeg', 0.85));
      } else {
        resolve(base64Str); // Fallback to original
      }
    };
    img.onerror = () => resolve(base64Str);
  });
}

function extractBase64Data(base64Str: string): { mimeType: string; imageData: string } {
  const matches = base64Str.match(/^data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+);base64,(.+)$/);
  if (!matches || matches.length !== 3) {
    throw new Error("Invalid image format");
  }
  return {
    mimeType: matches[1],
    imageData: matches[2]
  };
}

export async function transformToIllustration(
  base64Image: string, 
  style: ArtStyle = 'classic', 
  complexity: ComplexityLevel = 'medium'
): Promise<string> {
  const optimizedBase64 = await resizeImage(base64Image, 1024);
  const { mimeType, imageData } = extractBase64Data(optimizedBase64);

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY}`,
    },
    body: JSON.stringify({
      imageData,
      mimeType,
      style,
      complexity,
      mode: 'illustration'
    }),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || `Failed to generate illustration: ${response.status}`);
  }

  const data = await response.json();
  
  if (!data.imageUrl) {
    throw new Error("No illustration generated by the AI.");
  }

  return data.imageUrl;
}

export async function transformToLineArt(base64Image: string): Promise<string> {
  const optimizedBase64 = await resizeImage(base64Image, 1024);
  const { mimeType, imageData } = extractBase64Data(optimizedBase64);

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY}`,
    },
    body: JSON.stringify({
      imageData,
      mimeType,
      mode: 'line_art'
    }),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || `Failed to generate line art: ${response.status}`);
  }

  const data = await response.json();
  
  if (!data.imageUrl) {
    throw new Error("No line art generated.");
  }

  return data.imageUrl;
}
